{"instruction": "Given an array of integers, return the length of the longest increasing subsequence.", "input": "", "output": "1. Problem Restatement:\nWe are given an array of integers and must find the length of the longest subsequence where the elements are strictly increasing. The subsequence does not need to be contiguous.\n\n2. Approach / Intuition:\nWe can use dynamic programming. For each index i, we store the length of the longest increasing subsequence ending at i by checking all previous indices j < i with nums[j] < nums[i].\n\n3. Step-by-step Explanation:\n- Let nums be the input array and n = len(nums).\n- Create an array dp of size n, where dp[i] is the length of the LIS ending at index i.\n- Initialize dp[i] = 1 for all i, because each element alone is a subsequence of length 1.\n- For each i from 0 to n-1:\n  - For each j from 0 to i-1:\n    - If nums[j] < nums[i], then dp[i] = max(dp[i], dp[j] + 1).\n- The answer is max(dp).\n\n4. Final Code (with comments):\n```python\ndef length_of_lis(nums):\n    \"\"\"Return length of longest increasing subsequence using O(n^2) DP.\"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\nif __name__ == \"__main__\":\n    print(length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]))  # 4\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n^2).\n- Space Complexity: O(n).\n\n6. Edge Cases:\n- [] => 0\n- [1] => 1\n\n7. Sample Test Cases:\n- [] => 0\n- [1] => 1\n- [3, 3, 3] => 1\n- [10, 9, 2, 5, 3, 7, 101, 18] => 4"}
{"instruction": "Given a string, check if it is a palindrome. Ignore spaces and case.", "input": "", "output": "1. Problem Restatement:\nWe must check whether a string reads the same forwards and backwards if we ignore spaces and case.\n\n2. Approach / Intuition:\nNormalize the string (remove spaces, lowercase) and use two pointers from both ends.\n\n3. Step-by-step Explanation:\n- Take s as input.\n- Build clean by keeping only non-space characters and converting to lowercase.\n- Use left and right pointers.\n- Compare characters while left < right.\n\n4. Final Code (with comments):\n```python\ndef is_palindrome_ignore_space_case(s: str) -> bool:\n    \"\"\"Check if s is a palindrome, ignoring spaces and case.\"\"\"\n    clean = \"\".join(ch.lower() for ch in s if not ch.isspace())\n    left, right = 0, len(clean) - 1\n    while left < right:\n        if clean[left] != clean[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\nif __name__ == \"__main__\":\n    print(is_palindrome_ignore_space_case(\"Race car\"))  # True\n    print(is_palindrome_ignore_space_case(\"Hello\"))     # False\n```\n\n5. Time and Space Complexity:\n- Time: O(n).\n- Space: O(n).\n\n6. Edge Cases:\n- Empty string.\n- Spaces only.\n\n7. Sample Test Cases:\n- \"Race car\" => True\n- \"Hello\" => False\n- \"   \" => True"}
{"instruction": "Fix the bug in this Python function that is supposed to check if a string is a palindrome.", "input": "def is_palindrome(s: str) -> bool:\n    for i in range(len(s)):\n        if s[i] != s[len(s)-i-1]:\n            return False\n    return True", "output": "1. Problem Restatement:\nWe must fix a buggy implementation of a palindrome checker.\n\n2. Approach / Intuition:\nUse a two-pointer approach, comparing characters from both ends.\n\n3. Step-by-step Explanation of the Issue:\n- The loop iterates over the whole string, doing redundant checks.\n- A clearer approach is a while loop with left and right pointers.\n\n4. Final Code (with comments):\n```python\ndef is_palindrome(s: str) -> bool:\n    \"\"\"Return True if s is a palindrome, False otherwise.\"\"\"\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\nif __name__ == \"__main__\":\n    print(is_palindrome(\"racecar\"))  # True\n    print(is_palindrome(\"hello\"))    # False\n```\n\n5. Time and Space Complexity:\n- Time: O(n).\n- Space: O(1).\n\n6. Edge Cases:\n- Empty string.\n- Single-character string.\n\n7. Sample Test Cases:\n- \"racecar\" => True\n- \"hello\" => False\n- \"a\" => True"}
{"instruction": "Given an integer n, return the nth Fibonacci number using an efficient approach.", "input": "", "output": "1. Problem Restatement:\nCompute the nth Fibonacci number where F(0)=0, F(1)=1.\n\n2. Approach / Intuition:\nUse an iterative solution keeping only the last two values.\n\n3. Step-by-step Explanation:\n- Handle n=0 and n=1 separately.\n- Loop from 2 to n, updating prev2, prev1.\n\n4. Final Code (with comments):\n```python\ndef fib(n: int) -> int:\n    \"\"\"Return the nth Fibonacci number using O(1) space.\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    prev2, prev1 = 0, 1\n    for _ in range(2, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n    return prev1\n\nif __name__ == \"__main__\":\n    print(fib(0))   # 0\n    print(fib(1))   # 1\n    print(fib(10))  # 55\n```\n\n5. Time and Space Complexity:\n- Time: O(n).\n- Space: O(1).\n\n6. Edge Cases:\n- n=0.\n- n=1.\n\n7. Sample Test Cases:\n- 0 => 0\n- 1 => 1\n- 10 => 55"}
{"instruction": "Explain binary search and implement it iteratively in Python.", "input": "", "output": "1. Problem Restatement:\nWe are given a sorted array and a target value. We must determine the index of the target in the array using binary search, or return -1 if it is not present.\n\n2. Approach / Intuition:\nBinary search repeatedly halves the search space. Because the array is sorted, we compare the middle element with the target and decide whether to search the left half or the right half.\n\n3. Step-by-step Explanation:\n- Maintain two pointers: left and right for the current search range.\n- Compute mid = (left + right) // 2.\n- If arr[mid] == target, return mid.\n- If arr[mid] < target, move left = mid + 1.\n- Else move right = mid - 1.\n- If left exceeds right, the target is not in the array.\n\n4. Final Code (with comments):\n```python\ndef binary_search_iterative(arr, target):\n    \"\"\"Return index of target in sorted arr using iterative binary search, or -1 if not found.\"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\nif __name__ == '__main__':\n    print(binary_search_iterative([1, 3, 5, 7, 9], 7))   # 3\n    print(binary_search_iterative([1, 3, 5, 7, 9], 2))   # -1\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(log n) because we halve the search space each step.\n- Space Complexity: O(1) because we only use a few extra variables.\n\n6. Edge Cases:\n- Empty array.\n- Target smaller than the first element.\n- Target greater than the last element.\n- Array with one element.\n\n7. Sample Test Cases:\n- arr = [], target = 5 => -1\n- arr = [10], target = 10 => 0\n- arr = [1, 3, 5, 7, 9], target = 1 => 0\n- arr = [1, 3, 5, 7, 9], target = 9 => 4\n- arr = [1, 3, 5, 7, 9], target = 4 => -1"}
{"instruction": "Reverse a singly linked list in Python.", "input": "", "output": "1. Problem Restatement:\nWe are given the head of a singly linked list. We must reverse the list and return the new head.\n\n2. Approach / Intuition:\nWe can iteratively reverse the list by walking through nodes and flipping the next pointer at each step.\n\n3. Step-by-step Explanation:\n- Maintain three pointers: prev, curr, and nxt.\n- Initialize prev = None and curr = head.\n- While curr is not None:\n  - Store nxt = curr.next.\n  - Set curr.next = prev.\n  - Move prev to curr and curr to nxt.\n- At the end, prev points to the new head.\n\n4. Final Code (with comments):\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef reverse_list(head):\n    \"\"\"Reverse a singly linked list and return the new head.\"\"\"\n    prev = None\n    curr = head\n\n    while curr is not None:\n        nxt = curr.next      # store next node\n        curr.next = prev     # reverse link\n        prev = curr          # move prev forward\n        curr = nxt           # move curr forward\n\n    return prev\n\nif __name__ == '__main__':\n    # Example: 1 -> 2 -> 3\n    n3 = ListNode(3)\n    n2 = ListNode(2, n3)\n    n1 = ListNode(1, n2)\n    new_head = reverse_list(n1)\n    # new_head list is 3 -> 2 -> 1\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n) because we visit each node once.\n- Space Complexity: O(1) because we only use a few pointers.\n\n6. Edge Cases:\n- Empty list (head is None).\n- List with one node.\n\n7. Sample Test Cases:\n- head = None => None\n- head = 1 -> None => 1 -> None\n- head = 1 -> 2 -> 3 => 3 -> 2 -> 1"}
{"instruction": "Given an array of integers, find two numbers such that they add up to a specific target.", "input": "", "output": "1. Problem Restatement:\nWe are given an array of integers and a target value. We must return the indices of two numbers that add up to the target. Assume exactly one solution and that we cannot use the same element twice.\n\n2. Approach / Intuition:\nUse a hash map (dictionary) to store value -> index as we iterate the array. For each element, check if target - current exists in the map.\n\n3. Step-by-step Explanation:\n- Initialize an empty dictionary seen.\n- Iterate over array with index i and value num.\n- Compute complement = target - num.\n- If complement is in seen, return [seen[complement], i].\n- Otherwise, store seen[num] = i.\n\n4. Final Code (with comments):\n```python\ndef two_sum(nums, target):\n    \"\"\"Return indices of two numbers in nums that add up to target.\"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []  # theoretically unreachable if solution guaranteed\n\nif __name__ == '__main__':\n    print(two_sum([2, 7, 11, 15], 9))  # [0, 1]\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n) because we traverse the array once.\n- Space Complexity: O(n) for the dictionary.\n\n6. Edge Cases:\n- Minimal array length (2 elements).\n- Negative numbers.\n- Multiple possible pairs (but we only need one).\n\n7. Sample Test Cases:\n- nums = [2, 7, 11, 15], target = 9 => [0, 1]\n- nums = [3, 2, 4], target = 6 => [1, 2]\n- nums = [3, 3], target = 6 => [0, 1]"}
{"instruction": "Check if a string containing only '()[]{}' has valid parentheses.", "input": "", "output": "1. Problem Restatement:\nWe are given a string s containing only the characters '(', ')', '{', '}', '[' and ']'. We must determine if the string is a valid parentheses sequence.\n\n2. Approach / Intuition:\nUse a stack. Push opening brackets. When we see a closing bracket, check if it matches the top of the stack.\n\n3. Step-by-step Explanation:\n- Create a mapping from closing to opening brackets.\n- Iterate over each character ch in the string:\n  - If ch is an opening bracket, push it onto the stack.\n  - If ch is a closing bracket, check if stack is not empty and top matches the corresponding opening bracket.\n  - If not, return False.\n- At the end, return True if the stack is empty.\n\n4. Final Code (with comments):\n```python\ndef is_valid_parentheses(s):\n    \"\"\"Return True if s is a valid parentheses string.\"\"\"\n    stack = []\n    pairs = {')': '(', ']': '[', '}': '{'}\n\n    for ch in s:\n        if ch in '([{':\n            stack.append(ch)\n        else:\n            if not stack:\n                return False\n            if stack[-1] != pairs.get(ch):\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\nif __name__ == '__main__':\n    print(is_valid_parentheses('()[]{}'))     # True\n    print(is_valid_parentheses('(]'))         # False\n    print(is_valid_parentheses('([)]'))       # False\n    print(is_valid_parentheses('{[]}'))       # True\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n) where n is length of string.\n- Space Complexity: O(n) in worst case for the stack.\n\n6. Edge Cases:\n- Empty string (should be valid).\n- String starting with a closing bracket.\n- Odd-length string (cannot be valid).\n\n7. Sample Test Cases:\n- s = '' => True\n- s = '(' => False\n- s = '()[]{}' => True\n- s = '([)]' => False"}
{"instruction": "Merge two sorted arrays into one sorted array.", "input": "", "output": "1. Problem Restatement:\nWe are given two sorted arrays nums1 and nums2. We must merge them into a single sorted array.\n\n2. Approach / Intuition:\nUse two pointers, one for each array. Compare elements and push the smaller one into the result.\n\n3. Step-by-step Explanation:\n- Initialize i = 0, j = 0 and an empty result list.\n- While i < len(nums1) and j < len(nums2):\n  - If nums1[i] <= nums2[j], append nums1[i] and increment i.\n  - Else append nums2[j] and increment j.\n- Append the remaining elements from nums1 or nums2.\n\n4. Final Code (with comments):\n```python\ndef merge_sorted_arrays(nums1, nums2):\n    \"\"\"Merge two sorted lists into a new sorted list.\"\"\"\n    i, j = 0, 0\n    result = []\n\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] <= nums2[j]:\n            result.append(nums1[i])\n            i += 1\n        else:\n            result.append(nums2[j])\n            j += 1\n\n    # Append remaining elements\n    result.extend(nums1[i:])\n    result.extend(nums2[j:])\n\n    return result\n\nif __name__ == '__main__':\n    print(merge_sorted_arrays([1, 3, 5], [2, 4, 6]))  # [1, 2, 3, 4, 5, 6]\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(m + n), where m and n are lengths of input arrays.\n- Space Complexity: O(m + n) for the result array.\n\n6. Edge Cases:\n- One array empty.\n- Both arrays empty.\n- Arrays with duplicate values.\n\n7. Sample Test Cases:\n- nums1 = [], nums2 = [1, 2] => [1, 2]\n- nums1 = [1, 2], nums2 = [] => [1, 2]\n- nums1 = [1, 1, 1], nums2 = [1, 1] => [1, 1, 1, 1, 1]"}
{"instruction": "Perform level-order traversal (BFS) of a binary tree and return nodes level by level.", "input": "", "output": "1. Problem Restatement:\nWe are given the root of a binary tree. We must return a list of lists, where each inner list contains nodes at the same depth level (level-order traversal).\n\n2. Approach / Intuition:\nWe can perform breadth-first search (BFS) using a queue. Process nodes level by level and store their children.\n\n3. Step-by-step Explanation:\n- If root is None, return an empty list.\n- Initialize a queue with the root.\n- While the queue is not empty:\n  - Determine the current level size.\n  - For that many nodes, pop from queue, collect their values, and push their children.\n  - Append the level values to the answer.\n\n4. Final Code (with comments):\n```python\nfrom collections import deque\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef level_order(root):\n    \"\"\"Return level-order traversal of a binary tree as a list of lists.\"\"\"\n    if root is None:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_size = len(queue)\n        level_vals = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            level_vals.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(level_vals)\n\n    return result\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n), where n is number of nodes.\n- Space Complexity: O(n) for the queue and result in worst case.\n\n6. Edge Cases:\n- Empty tree.\n- Tree with only one node.\n- Highly skewed tree (like a linked list).\n\n7. Sample Test Cases:\n- root = None => []\n- root = 1 => [[1]]\n- root = [3, 9, 20, None, None, 15, 7] => [[3], [9, 20], [15, 7]]"}
{"instruction": "Detect if a singly linked list has a cycle.", "input": "", "output": "1. Problem Restatement:\nWe are given the head of a singly linked list. We must determine whether there is a cycle in it (i.e., a node that is visited again by following next pointers).\n\n2. Approach / Intuition:\nUse Floyd's Tortoise and Hare algorithm: two pointers moving at different speeds. If they ever meet, there's a cycle.\n\n3. Step-by-step Explanation:\n- Initialize two pointers slow and fast at head.\n- Move slow by one step and fast by two steps at a time.\n- If fast or fast.next becomes None, there is no cycle.\n- If slow == fast at any point, we have a cycle.\n\n4. Final Code (with comments):\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef has_cycle(head):\n    \"\"\"Return True if the linked list has a cycle, else False.\"\"\"\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow is fast:\n            return True\n\n    return False\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n) because at most linear steps are taken.\n- Space Complexity: O(1) since we only use two pointers.\n\n6. Edge Cases:\n- Empty list.\n- Single node with no cycle.\n- Single node pointing to itself (cycle).\n\n7. Sample Test Cases:\n- head = None => False\n- head = 1 -> 2 -> 3 -> None => False\n- head = 1 -> 2 -> 3 -> 2 (cycle) => True"}
{"instruction": "Implement merge sort for an array of integers in Python.", "input": "", "output": "1. Problem Restatement:\nWe must implement merge sort to sort an array of integers in non-decreasing order.\n\n2. Approach / Intuition:\nMerge sort is a divide-and-conquer algorithm. We split the array into two halves, recursively sort them, then merge the two sorted halves.\n\n3. Step-by-step Explanation:\n- Base case: if the array length is 0 or 1, it is already sorted.\n- Recursively split the array into left and right halves.\n- Recursively sort left and right.\n- Merge two sorted lists into one sorted list.\n\n4. Final Code (with comments):\n```python\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\n\ndef merge_sort(arr):\n    \"\"\"Sort arr using merge sort and return a new sorted list.\"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\nif __name__ == '__main__':\n    print(merge_sort([5, 2, 4, 6, 1, 3]))  # [1, 2, 3, 4, 5, 6]\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n log n).\n- Space Complexity: O(n) due to extra arrays used during merge steps.\n\n6. Edge Cases:\n- Empty array.\n- Array with one element.\n- Array with all equal elements.\n\n7. Sample Test Cases:\n- [] => []\n- [1] => [1]\n- [3, 3, 3] => [3, 3, 3]\n- [5, 2, 4, 6, 1, 3] => [1, 2, 3, 4, 5, 6]"}
{"instruction": "Find the length of the longest substring without repeating characters.", "input": "", "output": "1. Problem Restatement:\nGiven a string s, find the length of the longest substring without repeating characters.\n\n2. Approach / Intuition:\nUse a sliding window with a hash map that tracks the last seen index of each character. Expand the window and shrink from the left when a repeat is found.\n\n3. Step-by-step Explanation:\n- Maintain a dictionary last_seen mapping character to its latest index.\n- Maintain left pointer for the current window start and a variable max_len.\n- Iterate index right and character ch over s:\n  - If ch is in last_seen and last_seen[ch] >= left, move left to last_seen[ch] + 1.\n  - Update last_seen[ch] = right.\n  - Update max_len as max(max_len, right - left + 1).\n\n4. Final Code (with comments):\n```python\ndef length_of_longest_substring(s):\n    \"\"\"Return the length of the longest substring without repeating characters.\"\"\"\n    last_seen = {}\n    left = 0\n    max_len = 0\n\n    for right, ch in enumerate(s):\n        if ch in last_seen and last_seen[ch] >= left:\n            left = last_seen[ch] + 1\n        last_seen[ch] = right\n        max_len = max(max_len, right - left + 1)\n\n    return max_len\n\nif __name__ == '__main__':\n    print(length_of_longest_substring('abcabcbb'))  # 3\n    print(length_of_longest_substring('bbbbb'))     # 1\n    print(length_of_longest_substring('pwwkew'))    # 3\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n) because each index is visited at most twice.\n- Space Complexity: O(min(n, k)) where k is the character set size.\n\n6. Edge Cases:\n- Empty string.\n- String with all same characters.\n- String with all unique characters.\n\n7. Sample Test Cases:\n- '' => 0\n- 'aaaa' => 1\n- 'abcde' => 5\n- 'abba' => 2"}
{"instruction": "Implement an LRU (Least Recently Used) cache with get and put operations.", "input": "", "output": "1. Problem Restatement:\nDesign a data structure that supports LRU cache behavior with two operations: get(key) and put(key, value). get should return the value if key exists, else -1. When capacity is exceeded, evict the least recently used key.\n\n2. Approach / Intuition:\nWe need O(1) get and put and track recency. Use a combination of a dictionary (key -> node) and a doubly linked list to maintain usage order.\n\n3. Step-by-step Explanation:\n- Use a doubly linked list where head is most recently used and tail is least recently used.\n- Each node stores key and value.\n- Dictionary maps key to node.\n- get(key):\n  - If key not in map, return -1.\n  - Move node to head (most recent) and return its value.\n- put(key, value):\n  - If key is in map, update node's value and move it to head.\n  - Else create a new node, insert at head, add to map.\n  - If size exceeds capacity, remove tail node and delete from map.\n\n4. Final Code (with comments):\n```python\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.map = {}\n        # Dummy head and tail\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _remove(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n\n    def _add_to_head(self, node):\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n\n    def get(self, key: int) -> int:\n        if key not in self.map:\n            return -1\n        node = self.map[key]\n        self._remove(node)\n        self._add_to_head(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.map:\n            node = self.map[key]\n            node.value = value\n            self._remove(node)\n            self._add_to_head(node)\n            return\n\n        if len(self.map) >= self.capacity:\n            # evict least recently used: node before tail\n            lru = self.tail.prev\n            self._remove(lru)\n            del self.map[lru.key]\n\n        new_node = Node(key, value)\n        self._add_to_head(new_node)\n        self.map[key] = new_node\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(1) for both get and put.\n- Space Complexity: O(capacity) for storing nodes and map.\n\n6. Edge Cases:\n- Capacity = 0 (typically disallowed, but good to think about).\n- Repeated gets on same key.\n- Overwriting existing key.\n\n7. Sample Test Cases:\n- cache = LRUCache(2); put(1,1); put(2,2); get(1) => 1\n- put(3,3); get(2) => -1 (2 was evicted)\n- put(4,4); get(1) => -1; get(3) => 3; get(4) => 4"}
{"instruction": "Find the square root of a number in Python without using any external libraries.", "input": "", "output": "1. Problem Restatement:\nWe must implement a function to compute the square root of a non-negative number without using external libraries like math.sqrt.\n\n2. Approach / Intuition:\nWe can use Newton's method (also called the Newton-Raphson method) to iteratively approximate the square root.\n\n3. Step-by-step Explanation:\n- Let x be the input.\n- For x > 1, start with an initial guess g = x / 2.\n- Repeatedly update: g_new = (g + x / g) / 2.\n- Stop when the difference |g_new - g| is smaller than a small epsilon.\n\n4. Final Code (with comments):\n```python\ndef sqrt_newton(x, eps=1e-6):\n    \"\"\"Approximate square root of x using Newton's method.\"\"\"\n    if x < 0:\n        raise ValueError('sqrt_newton does not support negative numbers')\n    if x == 0:\n        return 0.0\n\n    g = x / 2.0  # initial guess\n    while True:\n        g_new = 0.5 * (g + x / g)\n        if abs(g_new - g) < eps:\n            return g_new\n        g = g_new\n\nif __name__ == '__main__':\n    print(sqrt_newton(4))    # ~2.0\n    print(sqrt_newton(9))    # ~3.0\n    print(sqrt_newton(0.25)) # ~0.5\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(log(precision)) iterations, each constant time.\n- Space Complexity: O(1).\n\n6. Edge Cases:\n- x = 0.\n- Very small positive numbers.\n- Negative numbers (we raise ValueError).\n\n7. Sample Test Cases:\n- x = 0 => 0.0\n- x = 1 => 1.0\n- x = 4 => ~2.0\n- x = 0.25 => ~0.5"}
{"instruction": "Fix the bug in this Python function that is supposed to compute factorial recursively.", "input": "def factorial(n):\n    if n == 0:\n        return 0\n    else:\n        return n * factorial(n-1)", "output": "1. Problem Restatement:\nWe are given a buggy implementation of a recursive factorial function. We must correct it so that it returns n! for n >= 0.\n\n2. Approach / Intuition:\nFactorial is defined as:\n- 0! = 1\n- n! = n * (n-1)! for n > 0\nThe base case in the given function is wrong; it returns 0 instead of 1.\n\n3. Step-by-step Explanation:\n- For n == 0, factorial should return 1.\n- For n > 0, factorial should return n * factorial(n-1).\n- Optionally, guard against negative n by raising an error.\n\n4. Final Code (with comments):\n```python\ndef factorial(n):\n    \"\"\"Return n! for n >= 0 using recursion.\"\"\"\n    if n < 0:\n        raise ValueError('factorial not defined for negative numbers')\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nif __name__ == '__main__':\n    print(factorial(0))  # 1\n    print(factorial(5))  # 120\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n) because we make n recursive calls.\n- Space Complexity: O(n) for the call stack.\n\n6. Edge Cases:\n- n = 0.\n- Negative n (we raise ValueError).\n\n7. Sample Test Cases:\n- n = 0 => 1\n- n = 1 => 1\n- n = 5 => 120\n- n = 10 => 3628800"}
{"instruction": "Given an array of integers, find the maximum subarray sum (Kadane's algorithm).", "input": "", "output": "1. Problem Restatement:\nWe are given an integer array nums. We must find the contiguous subarray with the largest sum and return that sum.\n\n2. Approach / Intuition:\nUse Kadane's algorithm. At each index, decide whether to start a new subarray at nums[i] or extend the previous one.\n\n3. Step-by-step Explanation:\n- Initialize current_sum = nums[0] and best_sum = nums[0].\n- For each element nums[i] from i = 1 to n-1:\n  - current_sum = max(nums[i], current_sum + nums[i]).\n  - best_sum = max(best_sum, current_sum).\n- Return best_sum in the end.\n\n4. Final Code (with comments):\n```python\ndef max_subarray_sum(nums):\n    \"\"\"Return the maximum subarray sum using Kadane's algorithm.\"\"\"\n    if not nums:\n        raise ValueError('nums must not be empty')\n\n    current_sum = nums[0]\n    best_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        best_sum = max(best_sum, current_sum)\n\n    return best_sum\n\nif __name__ == '__main__':\n    print(max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]))  # 6\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n).\n- Space Complexity: O(1).\n\n6. Edge Cases:\n- All negative numbers (still return the largest single element).\n- Single-element array.\n\n7. Sample Test Cases:\n- nums = [1] => 1\n- nums = [-1, -2, -3] => -1\n- nums = [-2,1,-3,4,-1,2,1,-5,4] => 6"}
{"instruction": "Given a sorted array of integers and a target, return the index of the first occurrence of the target using binary search.", "input": "", "output": "1. Problem Restatement:\nWe are given a sorted array nums (non-decreasing) and a target value. We must return the index of the *first* occurrence of target in nums, or -1 if target is not present.\n\n2. Approach / Intuition:\nInstead of returning as soon as we find target, we keep searching in the left half to see if there's an earlier occurrence. This is a variation of binary search.\n\n3. Step-by-step Explanation:\n- Initialize left = 0, right = len(nums) - 1, and ans = -1.\n- While left <= right:\n  - Compute mid = (left + right) // 2.\n  - If nums[mid] == target:\n    - Set ans = mid.\n    - Move right = mid - 1 to continue searching on the left side.\n  - Else if nums[mid] < target, move left = mid + 1.\n  - Else nums[mid] > target, move right = mid - 1.\n- After the loop, ans holds the first index or -1.\n\n4. Final Code (with comments):\n```python\ndef first_occurrence(nums, target):\n    \"\"\"Return the index of the first occurrence of target in sorted nums, or -1.\"\"\"\n    left, right = 0, len(nums) - 1\n    ans = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            ans = mid\n            right = mid - 1  # keep searching left side\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return ans\n\nif __name__ == '__main__':\n    print(first_occurrence([1, 2, 2, 2, 3], 2))  # 1\n    print(first_occurrence([1, 2, 3], 4))        # -1\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(log n) due to binary search.\n- Space Complexity: O(1).\n\n6. Edge Cases:\n- Empty array.\n- Target smaller than all elements.\n- Target larger than all elements.\n- All elements are equal to target.\n\n7. Sample Test Cases:\n- nums = [], target = 3 => -1\n- nums = [2, 2, 2], target = 2 => 0\n- nums = [1, 3, 5, 7], target = 1 => 0\n- nums = [1, 3, 5, 7], target = 7 => 3\n- nums = [1, 2, 3], target = 4 => -1"}
{"instruction": "Sort an array of 0s, 1s and 2s (Dutch national flag problem) without using extra space.", "input": "", "output": "1. Problem Restatement:\nWe are given an array consisting only of 0s, 1s, and 2s. We must sort it in-place so that all 0s come first, then 1s, then 2s.\n\n2. Approach / Intuition:\nUse three pointers: low, mid, and high.\n- low: boundary for 0s region.\n- mid: current element.\n- high: boundary for 2s region.\nWe swap elements into correct regions as we scan.\n\n3. Step-by-step Explanation:\n- Initialize low = 0, mid = 0, high = len(nums) - 1.\n- While mid <= high:\n  - If nums[mid] == 0:\n    - Swap nums[low] and nums[mid].\n    - Increment low and mid.\n  - Else if nums[mid] == 1:\n    - Just increment mid.\n  - Else (nums[mid] == 2):\n    - Swap nums[mid] and nums[high].\n    - Decrement high (do not increment mid yet).\n\n4. Final Code (with comments):\n```python\ndef sort_colors(nums):\n    \"\"\"Sort an array of 0s, 1s, and 2s in place using Dutch national flag algorithm.\"\"\"\n    low, mid, high = 0, 0, len(nums) - 1\n\n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:  # nums[mid] == 2\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1\n\nif __name__ == '__main__':\n    arr = [2, 0, 2, 1, 1, 0]\n    sort_colors(arr)\n    print(arr)  # [0, 0, 1, 1, 2, 2]\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n).\n- Space Complexity: O(1), as sorting is done in-place.\n\n6. Edge Cases:\n- Empty array.\n- Array with only one of the values (e.g., all 0s).\n\n7. Sample Test Cases:\n- [0, 1, 2] => [0, 1, 2]\n- [2, 2, 2] => [2, 2, 2]\n- [1, 0, 1, 0] => [0, 0, 1, 1]\n- [2, 0, 2, 1, 1, 0] => [0, 0, 1, 1, 2, 2]"}
{"instruction": "Explain and implement a function to check if a number is prime in Python.", "input": "", "output": "1. Problem Restatement:\nWe must write a function that takes an integer n and returns True if n is prime, and False otherwise.\n\n2. Approach / Intuition:\nA prime number is greater than 1 and has no positive divisors other than 1 and itself. We only need to check divisibility up to sqrt(n).\n\n3. Step-by-step Explanation:\n- If n <= 1, return False.\n- If n is 2 or 3, return True.\n- If n is divisible by 2, return False.\n- Loop i from 3 to int(sqrt(n)) with step 2:\n  - If n % i == 0, return False.\n- If no divisors found, return True.\n\n4. Final Code (with comments):\n```python\nimport math\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Return True if n is prime, False otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0:\n        return False\n\n    limit = int(math.sqrt(n))\n    for i in range(3, limit + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\nif __name__ == '__main__':\n    print(is_prime(2))   # True\n    print(is_prime(15))  # False\n    print(is_prime(17))  # True\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(sqrt(n)).\n- Space Complexity: O(1).\n\n6. Edge Cases:\n- n <= 1.\n- n = 2 (smallest prime).\n- Large prime numbers.\n\n7. Sample Test Cases:\n- n = -5 => False\n- n = 0 => False\n- n = 1 => False\n- n = 2 => True\n- n = 25 => False\n- n = 29 => True"}
{"instruction": "Explain and fix the bug in this Python code that tries to find the maximum element in a list.", "input": "def max_element(arr):\n    max_val = 0\n    for x in arr:\n        if x > max_val:\n            max_val = x\n    return max_val", "output": "1. Problem Restatement:\nWe are given a function that should return the maximum element of a list arr, but it has a bug. We must identify the issue and correct it.\n\n2. Approach / Intuition:\nThe function initializes max_val = 0. If all elements are negative, the function incorrectly returns 0 even if 0 is not in the list. The max should be initialized to the first element of the list.\n\n3. Step-by-step Explanation:\n- If arr is empty, we should raise an error or return None.\n- For non-empty arr, set max_val = arr[0].\n- Loop over the rest of the elements, updating max_val when we find a larger value.\n\n4. Final Code (with comments):\n```python\ndef max_element(arr):\n    \"\"\"Return the maximum element in arr. Raise ValueError if arr is empty.\"\"\"\n    if not arr:\n        raise ValueError('max_element() arg is an empty list')\n\n    max_val = arr[0]\n    for x in arr[1:]:\n        if x > max_val:\n            max_val = x\n    return max_val\n\nif __name__ == '__main__':\n    print(max_element([1, 5, 3]))     # 5\n    print(max_element([-10, -5, -7])) # -5\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n).\n- Space Complexity: O(1).\n\n6. Edge Cases:\n- Empty list (we raise ValueError).\n- List with one element.\n- List with all negative values.\n\n7. Sample Test Cases:\n- arr = [1] => 1\n- arr = [5, 5, 5] => 5\n- arr = [-1, -2, -3] => -1\n- arr = [] => ValueError"}
{"instruction": "The following code to compute Fibonacci numbers recursively is extremely slow for large n. Improve it.", "input": "def fib(n):\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)", "output": "1. Problem Restatement:\nWe are given a naive recursive implementation of the nth Fibonacci number. It works but is very slow for large n due to repeated computation. We must improve it.\n\n2. Approach / Intuition:\nThe naive recursion recomputes the same values many times. We can use either:\n- Memoization (top-down) or\n- Iterative approach (bottom-up) with O(1) space.\nWe'll implement an iterative solution.\n\n3. Step-by-step Explanation:\n- If n is 0 or 1, just return n.\n- Initialize two variables: prev2 = 0 (F(0)), prev1 = 1 (F(1)).\n- For i from 2 to n:\n  - curr = prev1 + prev2.\n  - Update prev2 = prev1, prev1 = curr.\n- Return prev1.\n\n4. Final Code (with comments):\n```python\ndef fib(n):\n    \"\"\"Return nth Fibonacci number using an iterative O(n) time and O(1) space approach.\"\"\"\n    if n < 0:\n        raise ValueError('n must be non-negative')\n    if n <= 1:\n        return n\n\n    prev2, prev1 = 0, 1\n    for _ in range(2, n + 1):\n        curr = prev1 + prev2\n        prev2, prev1 = prev1, curr\n    return prev1\n\nif __name__ == '__main__':\n    print(fib(0))   # 0\n    print(fib(1))   # 1\n    print(fib(10))  # 55\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n).\n- Space Complexity: O(1).\n\n6. Edge Cases:\n- n = 0.\n- n = 1.\n- Negative n (we raise ValueError).\n\n7. Sample Test Cases:\n- n = 0 => 0\n- n = 1 => 1\n- n = 5 => 5\n- n = 10 => 55"}
{"instruction": "Explain and fix the bug causing a ZeroDivisionError in this average calculation function.", "input": "def average(nums):\n    total = sum(nums)\n    return total / len(nums)", "output": "1. Problem Restatement:\nWe are given a function that computes the average of a list of numbers, but it raises ZeroDivisionError when the list is empty. We must handle this edge case correctly.\n\n2. Approach / Intuition:\nIf nums is empty, len(nums) is 0 and total / 0 is invalid. We should either return 0, None, or raise a more descriptive error. We'll raise ValueError with a clear message.\n\n3. Step-by-step Explanation:\n- Check if nums is empty at the start.\n- If it is, raise ValueError with an appropriate message.\n- Otherwise, compute sum and divide by len(nums).\n\n4. Final Code (with comments):\n```python\ndef average(nums):\n    \"\"\"Return the arithmetic mean of nums. Raise ValueError if nums is empty.\"\"\"\n    if not nums:\n        raise ValueError('average() arg is an empty list')\n    total = sum(nums)\n    return total / len(nums)\n\nif __name__ == '__main__':\n    print(average([1, 2, 3]))  # 2.0\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n) for summing n elements.\n- Space Complexity: O(1).\n\n6. Edge Cases:\n- Empty list (raise ValueError).\n- Single-element list.\n- Large lists.\n\n7. Sample Test Cases:\n- nums = [10] => 10.0\n- nums = [1, 2, 3, 4] => 2.5\n- nums = [] => ValueError"}
{"instruction": "Implement a function to remove duplicates from a sorted linked list.", "input": "", "output": "1. Problem Restatement:\nWe are given the head of a sorted singly linked list. We must remove duplicates so that each element appears only once, and return the head of the modified list.\n\n2. Approach / Intuition:\nSince the list is sorted, duplicates will be adjacent. We can traverse the list once and skip nodes whose value equals the current node's value.\n\n3. Step-by-step Explanation:\n- Start with current = head.\n- While current is not None and current.next is not None:\n  - If current.val == current.next.val, skip current.next by rewiring current.next = current.next.next.\n  - Else move current to current.next.\n- Return head.\n\n4. Final Code (with comments):\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef delete_duplicates(head):\n    \"\"\"Remove duplicates from a sorted linked list and return the head.\"\"\"\n    current = head\n    while current and current.next:\n        if current.val == current.next.val:\n            current.next = current.next.next\n        else:\n            current = current.next\n    return head\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n), where n is number of nodes.\n- Space Complexity: O(1).\n\n6. Edge Cases:\n- Empty list.\n- List with one node.\n- All nodes having the same value.\n\n7. Sample Test Cases:\n- 1 -> 1 -> 2 => 1 -> 2\n- 1 -> 1 -> 1 => 1\n- 1 -> 2 -> 3 => 1 -> 2 -> 3"}
{"instruction": "Implement a stack using two queues in Python.", "input": "", "output": "1. Problem Restatement:\nWe must implement a stack (LIFO) using two queues (FIFO). Operations to support: push(x), pop(), top(), and empty().\n\n2. Approach / Intuition:\nUse two queues q1 and q2. To make pop O(1), we can make push O(n) by rearranging elements.\n\n3. Step-by-step Explanation:\n- push(x):\n  - Enqueue x into q2.\n  - Dequeue all elements from q1 and enqueue into q2.\n  - Swap q1 and q2.\n- pop():\n  - Dequeue from q1.\n- top():\n  - Peek at front of q1.\n- empty():\n  - Check if q1 is empty.\n\n4. Final Code (with comments):\n```python\nfrom collections import deque\n\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        # Enqueue x into q2\n        self.q2.append(x)\n        # Move all elements from q1 to q2\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        # Swap q1 and q2\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return len(self.q1) == 0\n```\n\n5. Time and Space Complexity:\n- push: O(n) because we move all elements.\n- pop: O(1).\n- top: O(1).\n- empty: O(1).\n- Space Complexity: O(n) for storing elements.\n\n6. Edge Cases:\n- Popping or topping from an empty stack (could raise IndexError or be guarded).\n\n7. Sample Test Cases:\n- s = MyStack(); s.push(1); s.push(2); s.top() => 2; s.pop() => 2; s.empty() => False"}
{"instruction": "Explain and write code to check if two strings are anagrams of each other.", "input": "", "output": "1. Problem Restatement:\nWe are given two strings s and t. We must determine if t is an anagram of s (i.e., both contain the same characters with the same frequencies).\n\n2. Approach / Intuition:\nTwo strings are anagrams if sorting them yields the same string, or if their character counts match. We'll implement a counting-based approach using a dictionary.\n\n3. Step-by-step Explanation:\n- If lengths differ, they cannot be anagrams.\n- Create a dictionary count.\n- For each character ch in s, increment count[ch].\n- For each character ch in t, decrement count[ch].\n- If any value in count is non-zero, not an anagram.\n\n4. Final Code (with comments):\n```python\ndef is_anagram(s: str, t: str) -> bool:\n    \"\"\"Return True if t is an anagram of s, else False.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = {}\n    for ch in s:\n        count[ch] = count.get(ch, 0) + 1\n    for ch in t:\n        if ch not in count:\n            return False\n        count[ch] -= 1\n        if count[ch] < 0:\n            return False\n\n    return True\n\nif __name__ == '__main__':\n    print(is_anagram('anagram', 'nagaram'))  # True\n    print(is_anagram('rat', 'car'))          # False\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n) where n is length of strings.\n- Space Complexity: O(k) where k is the alphabet size (at most n unique chars).\n\n6. Edge Cases:\n- Empty strings (two empty strings are anagrams).\n- Case sensitivity (\"A\" vs \"a\" may be considered different unless normalized).\n\n7. Sample Test Cases:\n- s = \"\", t = \"\" => True\n- s = \"a\", t = \"a\" => True\n- s = \"a\", t = \"b\" => False\n- s = \"ab\", t = \"ba\" => True"}
{"instruction": "Write a Python function to validate if a string is a valid integer representation, handling optional leading +/- signs.", "input": "", "output": "1. Problem Restatement:\nWe must write a function that takes a string s and returns True if it represents a valid integer (e.g., \"123\", \"-42\", \"+7\"), and False otherwise.\n\n2. Approach / Intuition:\nWe check for an optional leading sign and ensure remaining characters are all digits. We must also reject empty string or string that is only a sign.\n\n3. Step-by-step Explanation:\n- Strip whitespace from s.\n- If s is empty after stripping, return False.\n- If s[0] is '+' or '-', then the rest must be non-empty and all digits.\n- If s[0] is not sign, then all characters must be digits.\n\n4. Final Code (with comments):\n```python\ndef is_valid_int_string(s: str) -> bool:\n    \"\"\"Return True if s is a valid integer string with optional leading +/- sign.\"\"\"\n    s = s.strip()\n    if not s:\n        return False\n\n    if s[0] in '+-':\n        if len(s) == 1:\n            return False\n        return s[1:].isdigit()\n    else:\n        return s.isdigit()\n\nif __name__ == '__main__':\n    print(is_valid_int_string('42'))     # True\n    print(is_valid_int_string('-42'))    # True\n    print(is_valid_int_string('+7'))     # True\n    print(is_valid_int_string('  -9 '))  # True\n    print(is_valid_int_string('+'))      # False\n    print(is_valid_int_string('abc'))    # False\n```\n\n5. Time and Space Complexity:\n- Time Complexity: O(n), where n is length of s.\n- Space Complexity: O(1) auxiliary space.\n\n6. Edge Cases:\n- Empty string.\n- String with only sign.\n- Leading/trailing spaces.\n- Non-digit characters.\n\n7. Sample Test Cases:\n- s = \"0\" => True\n- s = \"-0\" => True\n- s = \" 123 \" => True\n- s = \"12a\" => False"}
{"instruction": "I want the logic to calculate the square root of a number without using any external library in Python.", "input": "", "output": "1. Problem Restatement:\nWe need to compute the square root of a non-negative number x in Python **without** using built-in functions like math.sqrt or external libraries.\n\n2. Approach / Intuition:\nA classic way to approximate square roots numerically is **Newton's method** (also called the Babylonian method). We treat the square root problem as solving f(g) = g^2 - x = 0 and iteratively improve a guess g.\nThe update rule is:\n    g_new = 0.5 * (g + x / g)\nThis converges very quickly for positive x if we start from a reasonable initial guess.\n\n3. Step-by-step Explanation:\n- If x is negative, there is no real square root, so we raise a ValueError.\n- If x is 0, the answer is exactly 0.0, so we return 0.0 directly.\n- For x > 0, choose an initial guess, for example g = x or g = x / 2.\n- Repeatedly apply the Newton update:\n      g_new = 0.5 * (g + x / g)\n- Stop when the change |g_new - g| is smaller than a small epsilon (tolerance), e.g., 1e-6.\n- Return the final g_new as the approximate square root.\n\n4. Final Code (with comments):\n```python\ndef sqrt_newton(x: float, eps: float = 1e-6) -> float:\n    \"\"\"Approximate the square root of x using Newton's method.\n\n    Raises:\n        ValueError: if x is negative.\n    \"\"\"\n    if x < 0:\n        raise ValueError(\"sqrt_newton does not support negative numbers\")\n    if x == 0:\n        return 0.0\n\n    # Initial guess: you can also use x / 2.0\n    g = x\n\n    while True:\n        g_new = 0.5 * (g + x / g)\n        if abs(g_new - g) < eps:\n            return g_new\n        g = g_new\n\n\nif __name__ == \"__main__\":\n    print(sqrt_newton(4))      # ~2.0\n    print(sqrt_newton(9))      # ~3.0\n    print(sqrt_newton(0.25))   # ~0.5\n    print(sqrt_newton(2))      # ~1.4142\n```\n\n5. Time and Space Complexity:\n- Time Complexity: The number of iterations to converge is small for typical inputs and fixed precision, so it is effectively O(1) per call in practice.\n- Space Complexity: O(1), we only store a few scalar variables.\n\n6. Edge Cases:\n- x < 0: no real square root; we raise ValueError.\n- x = 0: return 0.0 directly.\n- Very small positive x: still converges, but using a tighter eps may require a few extra iterations.\n- Very large x: method still converges, but be mindful of floating-point precision limits.\n\n7. Sample Test Cases:\n- x = 0   => 0.0\n- x = 1   => 1.0\n- x = 4   => approximately 2.0\n- x = 9   => approximately 3.0\n- x = 0.25 => approximately 0.5\n- x = -1  => ValueError"}
